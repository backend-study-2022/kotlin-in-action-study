# 4. 클래스, 객체, 인터페이스
- 자바와 달리 코틀린 선언은 기본적으로 final이며 public 이다
- 게다가 중첩 클래스는 기본적으로 내부 클래스가 아니다
  - 코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다
- 코틀린 컴파일러는 번잡스러움을 피가이 위해 유용한 메서드를 자동으로 만들어줌
  - 클래스를 data 로 선언하면 컴파일러가 일부 표준 메소드를 생성
  - 코틀린 언어가 제공하는 위임(delegation)을 사용하면 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 ㅇ벗음

## 4.1 클래스 계층 정의
### 4.1.1 코틀린 인터페이스
- 코틀린 인터페이스는 자바 8 인터페이스와 비슷
- 코틀린 인터페이스 안에는 추상 메소드뿐 아니라 구현이 있는 메소드도 정의할 수 있음
- 자바에서는 extends, implements 키워드 사용
  - 코틀린에서는 클래스 이름 뒤에 콜론(:) -> 클래스 확장과 인터페이스 구현 모두 처리
- 인터페이스는 원하는 만큼 개수 제한 없음
- 클래스는 오직 하나만 확장 가능
- 코틀린에서는 override 변경자를 꼭 사용해야 한다
- default 키워드 사용 안해도 됨 그냥 메소드 본문 추가하면 됨

### 코틀린에서의 super
```kotlin
// kotlin
super<Clickable>.showOff()

// java
Clickable.super.showOff()
```

### 4.1.2 open, final, abstract 변경자: 기본적으로 final
- 자바에서는 final 로 명시적으로 상속을 금지하지 않는 모든 클래스를 다른 클래스가 상속할 수 있음
- 이에 따른 문제점
  - 취약한 기반 클래스 (fiagle base class) 문제
  - 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우
- 코틀린의 클래스와 메소드는 기본적으로 final 이다
- 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다
- 그와 더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙여야 함

### 오버라이드 금지하기
```kotlin
open class RichButton : Clickable {
    final override fun click() {}
}
```
- 기반 클래스나 인터페이스의 멤버를 오버라이드 하는 경우 그 메소드는 기본적으로 열려있음
- 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final 을 명시해야 함

### 열린 클래스와 스마트 캐스트
- 클래스의 기본적인 상속 가능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점
- 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능함
- 클래스 프로퍼티의 경우 이는 val 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 점
- 이 요구 사항은 또한 프로퍼티가 final 이어야만 한다는 뜻이기도 하다
- 프로퍼티가 final이 아니라면 그 프로퍼티를 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 꺨 수 있다
- 프로퍼티는 기본적으로 final 이기 때문에 따로 고민할 필요 없이 대부분의 프로퍼티르르 스마트 캐스트에 활용할 수 있다
- 이는 코드를 더 이해하기 쉽게 만든

### 추상 클래스 정의하기
- 코틀린에서도 클래스를 abstract 로 선언할 수 있다
- abstract 로 선언한 추상 클래스는 인스턴스화할 수 없다
- 추상 클래스에는 구현이 없는 추상 멤버가 있기 떄문에 하위 클래스에서 그 추상 멤버를 오버라이드 해야만 하는 게 보통
- 추상 멤버는 항상 열려있다
- 따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없음

| 변경자      | 이 변경자가 붙은 멤버는...               | 설명                                                         |
|----------|--------------------------------|------------------------------------------------------------|
| final    | 오버라이드 할 수 없음                   | 클래스 멤버의 기본 변경자                                             |
| open     | 오버라이드할 수 있음                    | 반드시 open을 명시해야 오버라이드할 수 있다                                 |
| abstract | 반드시 오버라이드 해야 함                 | 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상멤버에는 구현이 있으면 안 된다           |
| override | 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 중 | 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다 |

### 4.1.3 가시성 변경자: 기본적으로 공개
- 가시성 변경자(visibility modifier)
  - 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다
  - 어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있음
  - public, protected, private
  - 자바와 다른 점 : 아무 변경자도 없는 경우 선언은 모두 공개됨
  - 패키지 전용(package-private) 은 코틀린에 없음
  - 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용
- 패키지 전용 가시성에 대한 대안으로 코틀린에는 internal 이라는 새로운 가시성 변경자 도입
  - 모듈 내부에서만 볼 수 있음
  - 모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미
- 모듈 내부 가시성은 모듈의 구현에 대한 진정한 캡슐화를 제공한다
- 코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다

| 변경자             | 클래스 멤버             | 최상위 선언             |
|-----------------|--------------------|--------------------|
| public(기본 가시성임) | 모든 곳에서 볼 수 있다      | 모든 곳에서 볼 수 있다      |
| internal        | 같은 모듈 안에서만 볼 수 있다  | 같은 모듈 안에서만 볼 수 있다  |
| protected       | 하위 클래스 안에서만 볼 수 있다 | (최상위 선언에 적용할 수 없음) |
| private         | 같은 클래스 안에서만 볼 수 있다 | 같은 파일 안에서만 볼 수 있따  |

### 4.1.4 내부 클래스와 중첨된 클래스 : 기본적으로 중첩 클래스
- 코틀린에서도 클래스 안에 다른 클래스를 선언할 수 있다
- 클래스 안에 다른 클래스를 선언하면 도우미 클래스를 캡슐화하거나 코드 정의를 그 코드를 사용하는 곳 가까이에 두고 싶을 때 유용함
- 자바와의 차이점
  - 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점

### 4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한
- 코틀린 컴파일러는 when 을 사용해 Expr 타입의 값을 검사할 때 꼭 디폴트 분기인 else 분기를 덧붙이게 강제한다
- 디폴트 분기가 있으면 이런 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when 이 모든 경우를 처리하는지 제대로 검사할 수 없다
- 이런 문제에 대한 해법이 sealed 클래스!

### sealed 변경자
- 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다
- selaed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다
```kotlin
sealed class Expr { // 기반 클래스를 sealed 로 봉인한다
    class Num(val value: Int) : Expr()  // 기반 클래스의 모든 하위 클래스를 중첩 클래스로 나열한다
    class Sum(val left: Expr, val right: Expr) : Expr()
}

fun eval(e: Expr): Int =
    when (e) {      // when 식이 모든 하위 클래스를 검사하므로 별도의 else 분기가 없어도 된다
        is Expr.Num -> e.value
        is Expr.Sum -> eval(e.right) + eval(e.left)
    }
```
- when 식에서 sealed 클래스의 모든 하위 클래스를 처리한다면 디폴트 분기가 필요 없다
- sealed로 표시된 클래스는 자동으로 open 임을 기억하라
- 따라서 별도로 open 변경자를 붙일 필요가 없다
- 봉인된 클래스(sealed class) 는 클래스 외부에 자신을 상속한 클래스를 둘 수 없다
- sealed 클래스에 속한 값에 대해 디폴트 분기를 사용하지 않고 when 식을 사용하면 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 when 식이 컴파일 되지 않음
- 따라서 when 식을 고쳐야 한다는 사실을 쉽게 알 수 있음

## 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언
- 자바에서는 생성자를 하나 이상 선언할 수 있다
- 코틀린은 주(primary) 생성자와 부(secondary) 생성자를 구분한다
- 또한 코틀린에서는 초기화 블록을 통해 초기화 로직을 추가할 수 있다

### 4.2.1 클래스 초기화: 주 생성자와 초기화 블록
```kotlin
// 코틀린에서 클래스를 선언하는 방법
class User(val nickname: String)
```
- 보통 클래스의 모든 선언은 중괄호({}) 사이에 들어간다
- 하지만 이 클래스 선언에는 중괄호가 없고 괄호 사이에 val 선언만 존재한다
- 이렇게 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자(primary constructor) 라고 부른다
- 주 생성자는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다

```kotlin
class User constructor(_nickname: String) { // 파라미터가 하나만 있는 주 생성자
    val nickname: String
    init {  // 초기화 블록
        nickname = _nickname
    }
}
```
- constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용
- init 키워드는 초기화 블록을 시작한다
- 초기화 블록에는 클래스의 객체가 만들어질 때(인스턴스화될 때) 실행될 초기화 코드가 들어간다
- 초기화 블록은 주 생성자와 함께 사용된다
- 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다
- 필요하다면 클래스 안에 여러 초기화 블록을 선언할 수 있다
- 생성자 파라미터 \_nickname 에서 맨 앞의 밑줄(_)은 프로퍼티와 생성자 파라미터를 구분해준다
- 다른 방법으로 자바에서 흔히 쓰는 방식처럼 this.nickname = nickname 같은 식으로 써도 된다
- 이 예제에서는 nickname 프로퍼티를 초기화하는 코드를 nickname 프로퍼티 선언에 포함시킬 수 있어서 초기화 코드를 초기화 블록에 넣을 필요가 없다
- 또 주 생성자 앞에 별다른 애노테이션이나 가시성 변경자가 없다면 constructor 를 생략해도 된다
```kotlin
class User(_nickname: String) { // 파라미터가 하나뿐인 주 생성자
    val nickname = _nickname    // 프로퍼티를 주 생성자의 파라미터로 초기화한다
}
```
- 방금 살펴본 두 예제는 클래스 본문에서 val 키워드를 통해 프로퍼티를 정의했다
- 하지만 주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름 앞에 val 을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다
```kotlin
class User(val nickname: String) // val 은 이 파라미터에 상응하는 프로퍼티가 생성된다는 뜻이다.
```
- 함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 정의할 수 있다
```kotlin
class User(val nickname: String,    // 생성자 파라미터에 대한 디폴트 값을 제공한다
            val isSubscribed: Boolean = true)
```
```kotlin
// 정리
class User constructor(_nickname: String) { // 파라미터가 하나만 있는 주 생성자
  val nickname: String
  init {  // 초기화 블록
    nickname = _nickname
  }
}

class User(_nickname: String) { // 파라미터가 하나뿐인 주 생성자 ( constructor 생략가능 )
  val nickname = _nickname    // 프로퍼티를 주 생성자의 파라미터로 초기화한다
}

class User(val nickname: String)    // "val"은 이 파라미터에 상응하는 프로퍼티가 생성된다는 뜻

class User(val nickname: String,    // 생성자 파라미터에 대한 디폴트 값을 제공한 
           val isSubscribed: Boolean = true)
```
```kotlin
val hyun = User("현석")
println(hyun.isSubscribed)  // isSubscribed 파라미터에는 디폴트 값이 쓰인다

val gye = User("계명", false)
println(gye.isSubscribed)   // 모든 인자를 파라미터 선언 순서대로 지정할 수도 있다
    
val hey = User("혜원", isSubscribed = false)
println(hey.isSubscribed)
```

```kotlin
class TwitterUser(nickname: String) : User(nickname) {}
```
- 클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야 한다
- 기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다
```kotlin
open class Button
```
- 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다
```kotlin
class RadioButton: Button()
```
- Button의 생성자는 아무 인자도 받지 않지만, Button 클래스를 상속한 하위 클래스는 반드시 Button 클래스의 생성자를 호출해야 한다
- 인터페이스는 생성자가 없기 때문에 어떤 클래스가 인터페이스를 구현하는 경우 그 클래스의 상위 클래스 목록에 있는 인터페이스 이름 뒤에는 아무 괄호도 없다
- 클래스 정의에 있는 상위 클래스 및 인터페이스 목록에서 이름 뒤에 괄호가 붙었는지 살펴보면 쉽게 기반 클래스와 인터페이스를 구별할 수 있다
- 어떤 클래스를 클래스 외부에서 인스턴스화하지 못하게 막고 싶다면 모든 생성자를 private 으로 만들면 된다
- 다음과 같이 주 생성자에 private 변경자를 붙일 수 있다
```kotlin
class Secretvie private constructor() {} // 이 클래스의 유일한 주 생성자는 비공개다
```
- Secretive 클래스 안에는 주 생성자밖에 없고 그 주 생성자는 비공개이므로 외부에서는 Secretive를 인스턴스화 할 수 없다

### 4.2.2 부 생성자: 상위 클래스를 다른 방식으로 초기화
- 일반적으로 코틀린에서는 생성자가 여럿 있는 경우가 자바보다 훨씬 적다
- 자바에서 오버로드한 생성자가 필요한 상황 중 상당수는 코틀린의 디폴트 파라미터 값과 이름 붙인 인자 문법을 사용해 해결할 수 있다
> 인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말라
> 대신 파라미터의 디폴트 값을 생성자 시그니처에 직접 명시하라

### 생성자가 여럿 필요한 경우
- 프레임워크 클래스를 확장해야 하는데 여러 가지 방법으로 인스턴스를 초기화할 수 있게 다양한 생성자를 지원해야 하는 경우
- super() 키워드를 통해 자신에 대응하는 상위 클래스 생성자를 호출할 수 있다
- 파라미터의 디폴트 값을 넘겨서 같은 클래스의 다른 생성자에게 생성을 위임할 수도 있다
- 클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다
- 부 생성자가 필요한 이유는 자바 **상호운용성** 때문
- 또, 클래스 인스턴스를 생성할 때 파라미터 목록이 다른 생성 방법이 여럿 존재하는 경우에는 부 생성자를 여럿 둘 수밖에 없다

### 4.2.3 인터페이스에 선언된 프로퍼티 구현
```kotlin
interface User {
  val nickname: String
}
```
- 코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다
- 이는 User 인터페이스를 구현하는 클래스가 nickname의 값을 얻을 수 있는 방법을 제공해야 한다는 뜻
- 인터페이스에 있는 프로퍼티 선언에는 뒷받침하는 필드나 게터 등의 정보가 들어있지 않다.
- 사실 인터페이스는 아무 상태도 포함할 수 없으므로 상태를 저장할 필요가 있다면 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다

```kotlin
// 주 생성자 안에 프로퍼티를 직접 선언
class Privateuser(override val nickname: String) : Member

// 커스텀 게터로 nickname 프로퍼티를 설정
class SubscribingUser(val email: String) : Member {
    override val nickname: String
        get() = email.substringBefore('@') // 커스텀 게터
}
// 초기화 식으로 nickname 값을 초기화
// 매번 getter 로 가져올 때 비용이 많이 든다면,
// 객체 조기화 방법으로 한번만 호출하게 할 수도 있다
class FacebookUser(val accountId: Int) : Member {
    override val nickname = getFacebookName(accountId)

    private fun getFacebookName(accountId: Int) : String {
        return "test$accountId"
    }
}
```

### 4.2.4 게터와 세터에서 뒷받침하는 필드에 접근
- 지금까지 배운 프로퍼티의 두 가지 유형
  - 값을 저장하는 프로퍼티
  - 커스텀 접근자에서 매번 값을 계산하는 프로퍼티
- 이제는 두 유형을 조합해서 어떤 값을 저장하되 그 값을 변경하거나 읽을 때마다 정해직 로직을 실행하는 유형의 프로퍼티를 만드는 방법
- 값을 저장하는 동시에 로직을 실행할 수 있게 하기 위해서는 접근자 안에서 프로퍼티를 뒷받침하는 필드에 접근할 수 있어야 한다

```kotlin
class Customer(val name: String) {
    var address: String = "unspecified"
        set (value: String) {
        println("""
            Address was changed for $name:
            "$field" -> "$value".""".trimIndent()) // 뒷받침하는 필드 값 읽기
        field = value   // 뒷받침하는 필드 값 변경하기
    }
}
```
- 접근자의 본문에서는 field 라는 특별한 식별자를 통해 뒷받침하는 필드에 접근할 수 있다
- 게터에서는 field 값을 읽을 수만 있고 세터에서는 field 값을 읽거나 쓸 수 있다
- 변경 가능 프로퍼티의 게터와 세터 중 한쪽만 직접 정의해도 된다는 점!
- 컴파일러는 디폴트 접근자 구현을 사용하건 직접 게터나 세터를 정의하건 관계없이 게터나 세터에서 field 를 사용하는 프로퍼티에 대해 뒷받침하는 필드를 생성해준다
- 다만 field 를 사용하지 않는 커스텀 접근자 구현을 정의한다면 뒷받침하는 필드는 존재하지 않는다
> 프로퍼티가 val 인 경우에는 게터에 field 가 없으면 되지만 var 인 경우에는 게터나 세터 모두에 field 가 없어야 한다

### 4.2.5 접금자의 가시성 변경
- 접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다
- 하지만 원한다면 get 이나 set 앞에 가시성 변경자를 추가해서 접근자의 가시성을 변경할 수 있다

### 프로퍼티에 대해 나중에 다룰 내용
- `lateinit` 변경자를 **널이 될 수 없는 프로퍼티**에 지정하면 프로퍼티를 **생성자가 호출된 다음**에 초기화한다는 뜻이다
- 요청이 들어오면 비로소 초기화되는 지연 초기화(lazy initlalized) 프로퍼티는 더 일반적인 위임 프로퍼티의 일종
- 자바 프레임워크와의 호환성을 위해 자바의 특징을 코틀린에서 애뮬레이션하는 애노테이션을 활용할 수 있다
  - @JvmField : 접근자가 없는 public 필드를 노출시켜준다

## 4.3 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임
### 4.3.1 모든 클래스가 정의해야 하는 메소드
1. 문자열 표현: toString()
2. 객체의 동등성: equals()
### 동등성 연산에 == 를 사용함
- 자바
  - == : 원시타입과 참조 타입 비교
  - 원시 타입의 경우 값이 값은지 비교 (동등성)
  - 참조 타입의 경우 주소값이 같은지 비교 (참조 비교)
  - 객체의 동등성을 알고 싶은 경우 equals 호출해야 한다
- 코틀린
  - == 연산자가 두 객체를 비교하는 기본적인 방법
  - == 는 내부적으로 equals 를 호출해서 객체를 비교
  - 따라서 클래스가 equals 를 오버라이드 하면 == 를 통해 안전하게 인스턴스 비교가능
  - 참조 비교를 위해서는 === 사용
3. 해시 컨테이너: hashCode()
  - equals() 가 true 를 반환하는 두 객체는 반드시 같은 hashCode() 를 반환해야 한다
  - processed 집합은 HashSet 이다.
  - HashSet 은 원소를 비교할 때 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다

> 코틀린 컴파일러는 이 모든 메소드를 자동으로 생성해줄 수 있다

### 4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성
- 어떤 클래스가 데이터를 저장하는 역할만을 수행한다면 toString, equals, hashCode 를 반드시 오버라이드 해야 한다
- 코틀린은 이런 메소드를 IDE를 통해 생성할 필요 없다
- data 라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다

### 데이터 클래스와 불변성: copy() 메소드
- 데이터 클래스의 프로퍼티가 꼭 val 일 필요는 없다
- 원한다면 var 프로퍼티를 써도 된다
- 하지만 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만들어서 데이터 클래스를 불변 클래스로 만들라고 권장한다
- HashMap 등의 컨테이너에 데이터 클래스 객체를 담는 경우엔 불변성이 필수적이다
- 불변 객체를 사용하면 프로그램에 대해 훨씬 쉽게 추론할 수 있다
- 특히 다중스레드 프로그램의 경우 이런 성질은 더욱 중요하다
- 불변 객체를 주로 사용하는 프로그램에서는 스레드가 사용 중인 데이터를 다른 스레드가 변경할 수 없으므로 스레드를 동기화해야 할 필요가 줄어든다
- 데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 한 가지 편의 메소드를 제공한다
- 이것이 바로 copy 메소드

### 4.3.3 클래스 위임: by 키워드 사용
- 데코레이터(Decorator) 패턴
  - 상속을 허용하지 않는 클래스 대신 사용할 수 있는 새로운 클래스를 만들되 기존 클래스와 같은 인터페이스를 데코레이터가 제공하게 만들고
  - 기존 클래스를 데코레이터 내부에 필드로 유지하는 것
  - 이때 새로 정의해야 하는 기능은 데코레이터의 메소드에 새로 정의
  - 기존 기능이 그대로 필요한 부분은 데코레이터의 메소드가 기존 클래스의 메소드에게 요청을 전달

## 4.4 object 키워드: 클래스 선언과 인스턴스 생성
### object 키워드를 사용하는 상황
- 객체 선언(object declaration) - 하나만 선언해야 할 때
- 동반 객체(companion object)
- 무명 내부 클래스(anonymous inner class)

### 4.4.1 객체 선언: 싱글턴을 쉽게 만들기 - object
- 자바에서는 보통 클래스의 생성자를 private 으로 제한하고 정적인 필드에 그 클래스의 유일한 객체를 선언하는 싱글턴 패턴을 통해 구현
- 코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원함
- 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다

### 4.4.2 동반 객체: 팩토리 메소드와 정적 멤버가 들어갈 장소
- 코틀린 클래스 안에는 정적인 멤버가 없다
- 코틀린 언어는 자바 static 키워드를 지원하지 않는다
- 그 대신 코틀린에서는 패키지 수준의 최상위 함수와 객체 선언을 활용한다
- 하지만 최상위 함수는 private 으로 표시된 클래스 비공개 멤버에 접근할 수 없다
- 그래서 클래스의 인스턴스와 관계없이 호출해야 하지만 클래스 내부 정보에 접근해야 하는 함수가 필요할 때는 클래스에 중첩된 객체 선언의 멤버 함수로 정의해야 한다
- 클래스 안에 정의된 객체 중 하나에 `companion` 이라는 특별한 표시를 붙이면 그 클래스의 동반 객체로 만들 수 있다
- 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다

```kotlin
class A {
    companion object {
        fun bar() {
            println("Companion object called")
        }
    }
}
```
```kotlin
class User3 private constructor(val nickname: String) {
    companion object {
        fun newSubscribingUser(email: String) =
            User3(email.substringBefore('@'))
        fun newFacebookUser(accountId: Int) =
            User3(getFacebookName(accountId))
    }
}
```
- 팩토리 메소드는 매우 유용하다
- 팩토리 메소드는 메소드 이름을 정할 수 있다
- 팩토리 메소드가 선언된 클래스의 하위 클래스 객체를 반환할 수도 있다
- 예를 들어 SubscribingUser 와 FacebookUser 클래스가 따로 존재한다면
- 그때그때 필요에 따라 적당한 클래스의 객체를 반환할 수 있다
- 또 팩토리 메소드는 생성할 필요가 없는 객체를 생성하지 않을 수도 있다
- 하지만 클래스를 확장해야만 하는 경우에는 동반 객체 멤버를 하위 클래스에서 오버라이드할 수 없으므로 여러 생성자를 사용하는 편이 낫다

### 4.4.3 동반 객체를 일반 객체처럼 사용
- 동반 객체는 클래스 안에 정의된 일반 객체다
- 따라서 동반 객체에 이름을 붙이거나, 동반 객체가 인터페이스를 상속하거나 동반 객체 안에 확장 함수와 프로퍼티를 정의할 수 있다

### 동반 객체에서 인터페이스 구현하기
```kotlin
interface JSONFactory<T> {
    fun fromJSON(jsonText: String): T
}
class Board(val name: String) {
    companion object : JSONFactory<Board> {
        override fun fromJSON(jsonText: String): Board = 
            Board(jsonText.substringBefore("@"))
    }   // <- 동반 객체가 인터페이스를 구현한다
}
fun loadFromJSON<T>(factory: JSONFactory<T>): T {
    ...
}
loadFromJSON(Board) // <- 동반 객체의 인스턴스를 함수에 넘긴다
```
### 코틀린 동반 객체와 정적 멤버
- 클래스의 동반 객체는 일반 객체와 비슷한 방식으로 클래스에 정의된 인스턴스를 가리키는 정적 필드로 컴파일된다
- 동반 객체에 이름을 붙이지 않았다면 자바 쪽에서 Companion 이라는 이름으로 그 참조에 접근할 수 있다
- 동반 객체에게 이름을 붙였다면 Companion 대신 그 이름이 쓰인다
- 때로 자바에서 사용하기 위해 코틀린 클래스의 멤버를 정적인 멤버로 만들어야 할 필요가 있다
- 그런 경우 @JvmStatic 애노테이션을 코틀린 멤버에 붙이면 된다
- 정적 필드가 필요하다면 @JvmField 애노테이션을 최상위 프로퍼티나 객체에서 선언된 프로퍼티 앞에 붙인다
- 이 기능은 자바와의 상호운용성을 위해 존재하며 정확히 말하자면 코틀린 핵심 언어가 제공하는 기능은 아니다
- 코틀린에서도 자바의 정적 필드나 메소드를 사용할 수 있는데 이 경우 자바와 똑같은 구문을 사용한다

### 동반 객체 확장
- 자바의 정적 메소드나 코틀린의 동반 객체 메소드처럼 기존 클래스에 대해 호출할 수 있는 새로운 함수를 정의하고 싶다면?
- 클래스에 동반 객체가 있으면 그 객체 안에 함수를 정의함으로써 클래스에 대해 호출할 수 있는 확장 함수를 만들 수 있따
- C 라는 클래스 안에 동반 객체가 있고 그 동반 객체 안에 func 를 정의하면 외부에서는 func() 을 C.func() 로 호출

```kotlin
// 4.29 동반 객체에 대한 확장 함수 정의하기
// 비즈니스 로직 모듈
class Person2(val firstName: String, val lastName: String) {
    companion object {
        // 비어있는 동반 객체를 선언한다
    }
}
// 클라이언트/서버 통신 모듈
fun Person2.Companion.fromJSON(json: String): Person { // 확장 함수를 선언한다
    return Person("test")
}
val p = Person.fromJSON(json)
```
- 마치 동반 객체 안에서 fromJSON 함수를 정의한 것처럼 fromJSON을 호출 할 수 있다
- 하지만 실제로 fromJSON 은 클래스 밖에서 정의한 확장 함수다
- 다른 보통 확장 함수처럼 fromJSON도 클래스 멤버 함수처럼 보이지만, 실제로는 멤버 함수가 아니다
- 여기서 동반 객체에 대한 확장 함수를 작성할 수 있으려면 원래 클래스에 동반 객체를 꼭 선언해야 한다는 점에 유의
- 설령 빈 객체라도 동반 객체가 꼭 있어야 한다

### 4.4.4 객체 식: 무명 내부 클래스를 다른 방식으로 작성
- object 키워드를 싱글턴과 같은 객체를 정의하고 그 객체에 이름을 붙일 때만 사용하지 않는다
- 무명 객체를 정의할 때도 object 키워드를 쓴다
- 무명 객체는 자바의 무명 내부 클래스를 대신한다

```kotlin
val listener = object : MouseAdapter() {
  override fun mouseClicked(e: MouseEvent) {...}
  override fun mouseEntered(e: MouseEvent) {...}
}
```
- 코틀린 무명 클래스는 여러 인터페이스를 구현하거나 클래스를 확장하면서 인터페이스를 구현할 수 있다
> 객체 선언과 달리 무명 객체는 싱글턴이 아니다
> 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다

### 무명 객체 안에서 로컬 변수 사용하기

```kotlin
fun countClicks(window: Window) {
  var clickCount = 0 // 로컬 변수를 정의한다
  window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        clickCount++ // 로컬 변수의 값을 변경한다
    }
  })
}
```
- 자바와 달리 코틀린에서는 final 이 아닌 변수도 객체 식 안에서 사용할 수 있다