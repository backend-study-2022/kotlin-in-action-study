### 3.2.3 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티
- 코틀린에서는 무의미한 클래스가 필요 없음
- 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 됨
- 그런 함수들은 여전히 그 파일의 맨 앞에 정의된 패키지의 하위 멤버 함수 이므로 다른 패키지에서 그 함수를 사용하고 싶을 때는 그 함수가 정의된 패키지를 임프로해야만 함
- 하지만 임포트 시 유틸리티 클래스 이름이 추가로 들어갈 필요는 없능

### 3.3.1 임포트와 확장 함수
- 코틀린에서는 클래스를 임포트할 때와 동일한 구문을 사용해 개별 함수를 임포트 할 수 있다
```kotlin
import strings.lastChar
val c = "Kotlin".lastChar()

// as 키워드 사용하면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다
import strings.lastChar as last
val c = "Kotlin".last()
```
- 한 파일 안에서 다른 여러 패키지에 속해있는 이름이 같은 함수를 가져와 사용해야 하는 경우 이름을 바꿔 임포트하면 이름 충돌을 막을 수 있음

### 3.3.4 확장 함수는 오버라이드 할 수 없다
- 확장 함수는 클래스의 일부가 아니다
- 확장 함수는 클래스 밖에 선언된다
- 이름과 파라미터가 완전히 같은 확장 함수를 기반 클래스와 하위 클래스에 대해 정의해도 실제로는 확장 함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정되지, 그 변수에 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다
```kotlin
fun View.showOff() = println("I'm a view!")
fun Button.showOff() = println("I'm a button!")

val view: View = Button()
view.showOff()

>> I'm view!
```
- view 가 가리키는 객체의 실제 타입이 Button 이지만, 이 경우 view 의 타입이 View 이기 때문에 무조건 View 의 확장 함수가 호출된다
- 코틀린은 호출될 확장 함수를 정적으로 결정하기 때문
- 어떤 클래스를 확장한 함수와 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출된다
- 멤버 함수의 우선순위가 더 높음